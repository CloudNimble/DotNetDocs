<Project>
    <!-- ============================================================================
        DotNetDocs.Sdk - Targets

        Provides build targets for documentation projects (.docsproj)
        Includes validation, generation, and integration targets.
        ============================================================================ -->

    <Import Sdk="Microsoft.Build.NoTargets"  Version="3.7.0" Project="Sdk.targets" />
    
    <!-- Determine which task assembly to load based on MSBuild runtime -->
    <PropertyGroup>
        <!-- Determine the target framework for tasks based on MSBuild runtime -->
        <_DotNetDocsTaskFramework Condition="'$(MSBuildRuntimeType)' == 'Core'">net8.0</_DotNetDocsTaskFramework>
        <_DotNetDocsTaskFramework Condition="'$(MSBuildRuntimeType)' == 'Full'">net472</_DotNetDocsTaskFramework>
        <_DotNetDocsTaskFramework Condition="'$(_DotNetDocsTaskFramework)' == ''">net8.0</_DotNetDocsTaskFramework>
        
        <!-- Tasks are always loaded from the packaged location -->
        <_DotNetDocsTasksFolder>$(MSBuildThisFileDirectory)..\tasks\$(_DotNetDocsTaskFramework)</_DotNetDocsTasksFolder>
        <_DotNetDocsTasksAssembly>$(_DotNetDocsTasksFolder)\CloudNimble.DotNetDocs.Sdk.Tasks.dll</_DotNetDocsTasksAssembly>

        <PrepareProjectReferencesDependsOn>AssignDocumentationProjectReferences</PrepareProjectReferencesDependsOn>
    </PropertyGroup>
    
    <UsingTask TaskName="CloudNimble.DotNetDocs.Sdk.Tasks.GenerateDocumentationTask" 
               AssemblyFile="$(_DotNetDocsTasksAssembly)"/>

    <!-- Synthetically creates ProjectReferences from this project to a broad cone of other projects in the workspace so that MSBuild
         Common Targets will handle discovering the proper TFMs/Configuration/Platform/etc based on the parameters
         used when building _this_ project -->
    <Target Name="AssignDocumentationProjectReferences">
        <ItemGroup>
            <!-- 
                Start with all projects, then use a series of MSBuild invocations to decide which ones to orchestrate.
                In general, to generate docs we need the primary output path and xmldoc paths for referenceable assemblies.
                In MSBuild parlance, this means that we need to OutputPath and DocumentationFile properties from each project.
                We also need to ensure that such projects are actually _built_ so that their outputs are available.
            -->
            <_AllProjectsInRoot Include="$(MSBuildProjectDirectory)\..\**\*.*proj" Exclude="@(ExcludePatterns)"/>
            <ProjectReference Include="@(_AllProjectsInRoot)" />
        </ItemGroup>
    </Target>

    <!-- Discover documented projects in solution for documentation generation -->
    <!-- _MSBuildProjectReferenceExistent Items now exist thanks to PrepareProjectReferences.
         From this set, we can call a couple Targets to determine which of these should actually be used to generate documentation -->
    <!-- We can get documentation files for projects from the DocumentationProjectOutputGroup Target, 
        and dlls from the BuiltProjectOutputGroup Target. HOWEVER these only exist on single-TFM projects, so 
        first we need to ensure that we have 'negotiated' the correct TFM (and other properties) for each project. 
    -->
    <Target Name="DiscoverDocumentedProjects" Condition="'$(GenerateDocumentation)' == 'true'" DependsOnTargets="PrepareProjectReferences">
        <MSBuild Projects="@(_MSBuildProjectReferenceExistent)"
                 Targets="DocumentationProjectOutputGroup"
                 SkipNonexistentTargets="true"
                 BuildInParallel="true">
            <Output TaskParameter="TargetOutputs" ItemName="_ProjectDocFiles" />
        </MSBuild>

        <!-- The _ProjectDocFiles items will have MSBuildSourceProjectFile metadata noting the project they came from.
             We will assume that any item in this list belongs to a project that will actually generate docs for us to work with.
            We take those _MSBuildProjectReferenceExistent so that they continue to have all the relevant properties set for future use.  -->
        <ItemGroup>
            <DocumentedProjects Include="@(_MSBuildProjectReferenceExistent)" 
                                Condition="%(_MSBuildProjectReferenceExistent->'Identity') == %(_ProjectDocFiles->'MSBuildSourceProjectFile')"
                                DocFile="%(ProjectDocFiles.Identity)" />
        </ItemGroup>
        
        <!-- We also need to compute the dll outputs for the documented projects so we can get the dlls. Both the dlls and the xml docs will be 
             Inputs to doc generation to allow for incrementality. -->
        <MSBuild Projects="@(DocumentedProjects)"
                 Targets="BuiltProjectOutputGroup"
                 SkipNonexistentTargets="true"
                 BuildInParallel="true">
            <Output TaskParameter="TargetOutputs" ItemName="_ProjectBuildOutputs" />
        </MSBuild>
        <ItemGroup>
            <DocumentedProjects Update="@(DocumentedProjects)" 
                                AssemblyFile="%(_ProjectBuildOutputs->WithMetadata('MSBuildSourceProjectFile','%(DocumentedProjects.Identity)'))" />
        </ItemGroup>
    </Target>

    <!-- Generate documentation from existing assemblies. TODO: is it possible to compute the set of outputs that are expected? That would help incrementality a ton -->
    <Target Name="GenerateDocumentation"
            Condition="'$(GenerateDocumentation)' == 'true'"
            DependsOnTargets="DiscoverDocumentedProjects"
            Inputs="@(DocumentedProjects->'%(AssemblyFile)');@(DocumentedProjects->'%(DocFile)')">
        <Message Text="ðŸš€ Generating documentation from existing assemblies..." Importance="high" />

        <!-- Extract assembly paths from built projects (only main project assemblies) -->
        <ItemGroup>
            <!-- Get assembly paths using the actual target framework from each project -->
            <AssemblyPaths Include="%(DocumentedProjects.AssemblyFile)" />
            <XmlDocPaths Include="%(DocumentedProjects.DocFile)" />
        </ItemGroup>

        <!-- Call DocumentationManager to process assemblies -->
        <PropertyGroup>
            <DocumentationRootPath>$(MSBuildProjectDirectory)</DocumentationRootPath>
            <NamespaceModeProperty>$(NamespaceMode)</NamespaceModeProperty>
        </PropertyGroup>

        <!-- Use compiled task to generate documentation -->
        <CloudNimble.DotNetDocs.Sdk.Tasks.GenerateDocumentationTask
            Assemblies="@(AssemblyPaths)"
            OutputPath="$(DocumentationRootPath)"
            DocumentationType="$(DocumentationType)"
            NamespaceMode="$(NamespaceMode)"
            ApiReferencePath="$(ApiReferencePath)"
            MintlifyNavigationMode="$(MintlifyNavigationMode)"
            MintlifyUnifiedGroupName="$(MintlifyUnifiedGroupName)"
            DocsJsonTemplatePath="$(DocsJsonTemplatePath)"
            MintlifyTemplate="$(MintlifyTemplate)"
            SolutionName="$(_SolutionName)"
            ConceptualDocsEnabled="$(ConceptualDocsEnabled)"
            ShowPlaceholders="$(ShowPlaceholders)">
            <Output TaskParameter="GeneratedFiles" ItemName="GeneratedDocumentationFiles" />
        </CloudNimble.DotNetDocs.Sdk.Tasks.GenerateDocumentationTask>
        
        <ItemGroup>
            <FileWrites Include="GeneratedDocumentationFiles" />
        </ItemGroup>

        <!-- Check result -->
        <Message Text="âœ… Documentation generation completed successfully" Importance="high" />
    </Target>

    <!-- Documentation project statistics -->
    <Target Name="DocumentationStats"
            Condition="'$(ShowDocumentationStats)' == 'true'">
        <Message Text="ðŸ“Š Documentation Statistics:" Importance="high" />

        <ItemGroup>
            <MarkdownFiles Include="$(DocumentationRoot)**/*.md" />
            <MarkdownFiles Include="$(DocumentationRoot)**/*.mdx" />
            <MarkdownFiles Include="$(DocumentationRoot)**/*.mdz" />
            <ImageFiles Include="$(DocumentationRoot)**/*.png;$(DocumentationRoot)**/*.jpg;$(DocumentationRoot)**/*.jpeg;$(DocumentationRoot)**/*.gif;$(DocumentationRoot)**/*.svg" />
        </ItemGroup>

        <Message Text="   ðŸ“„ Documentation type: $(DocumentationType)" Importance="high" />
        <Message Text="   ðŸ“ Markdown files: @(MarkdownFiles->Count())" Importance="high" />
        <Message Text="   ðŸ–¼ï¸ Image files: @(ImageFiles->Count())" Importance="high" />
    </Target>

    <!-- Override GetTargetPath to provide a marker file for terminal logger -->
    <!-- This overrides the empty GetTargetPath from NoTargets SDK -->
    <Target Name="GetTargetPath" Returns="@(TargetPathItem)">
        <PropertyGroup>
            <!-- Create a marker file path that represents our documentation output -->
            <!-- This needs to be a file path, not a directory, to avoid MSB3024 error -->
            <TargetPath>$(MSBuildProjectDirectory)\bin\$(Configuration)\$(MSBuildProjectName).docmarker</TargetPath>
        </PropertyGroup>
        <ItemGroup>
            <TargetPathItem Include="$(TargetPath)">
                <TargetFramework>$(TargetFramework)</TargetFramework>
            </TargetPathItem>
        </ItemGroup>
    </Target>

    <!-- Override GetTargetPathWithTargetPlatformMoniker as well -->
    <Target Name="GetTargetPathWithTargetPlatformMoniker" Returns="@(TargetPathWithTargetPlatformMoniker)">
        <PropertyGroup>
            <!-- Use the same marker file path as GetTargetPath -->
            <TargetPath>$(MSBuildProjectDirectory)\bin\$(Configuration)\$(MSBuildProjectName).docmarker</TargetPath>
        </PropertyGroup>
        <ItemGroup>
            <TargetPathWithTargetPlatformMoniker Include="$(TargetPath)">
                <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
                <TargetFramework>$(TargetFramework)</TargetFramework>
            </TargetPathWithTargetPlatformMoniker>
        </ItemGroup>
    </Target>
    
    <!-- Override CopyFilesToOutputDirectory to prevent the copy operation entirely -->
    <!-- Since we're a documentation project, we don't need to copy files to output -->
    <Target Name="CopyFilesToOutputDirectory" />

    <!-- Define a Build target that runs documentation generation -->
    <!-- This allows 'dotnet build' and Visual Studio builds to work -->
    <Target Name="Build" DependsOnTargets="GenerateDocumentation">
        <Message Text="âœ… Documentation build completed" Importance="high" />
    </Target>

    <!-- Help target to show available options -->
    <Target Name="DocumentationHelp">
        <Message Text="" Importance="high" />
        <Message Text="ðŸ“š DotNetDocs.Sdk Help" Importance="high" />
        <Message Text="â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" Importance="high" />
        <Message Text="" Importance="high" />
        <Message Text="Available Properties:" Importance="high" />
        <Message Text="  GenerateDocumentation=true    - Generate docs from all packable projects in solution" Importance="high" />
        <Message Text="  GenerateMintlifyDocs=true     - Auto-generate Mintlify docs on build" Importance="high" />
        <Message Text="  LintMarkdown=true             - Lint markdown files on build" Importance="high" />
        <Message Text="  PreviewDocumentation=true     - Start preview server on build" Importance="high" />
        <Message Text="  ShowDocumentationStats=true   - Show documentation statistics" Importance="high" />
        <Message Text="  DeployDocumentation=true      - Deploy documentation after build" Importance="high" />
        <Message Text="" Importance="high" />
        <Message Text="Available Targets:" Importance="high" />
        <Message Text="  dotnet build -t:DocumentationHelp       - Show this help" Importance="high" />
        <Message Text="  dotnet build -t:DocumentationStats      - Show documentation statistics" Importance="high" />
        <Message Text="  dotnet build -t:GenerateDocumentation    - Generate unified documentation" Importance="high" />
        <Message Text="  dotnet build -t:GenerateMintlifyDocs     - Generate Mintlify documentation" Importance="high" />
        <Message Text="  dotnet build -t:LintMarkdown             - Lint markdown files" Importance="high" />
        <Message Text="  dotnet build -t:PreviewDocumentation     - Start preview server" Importance="high" />
        <Message Text="" Importance="high" />
        <Message Text="Current Configuration:" Importance="high" />
        <Message Text="  Documentation Type: $(DocumentationType)" Importance="high" />
        <Message Text="  Documentation Root: $(DocumentationRoot)" Importance="high" />
        <Message Text="  Output Location: $(ApiReferencePath)" Importance="high" />
        <Message Text="  Generate Documentation: $(GenerateDocumentation)" Importance="high" />
        <Message Text="" Importance="high" />
    </Target>

</Project>