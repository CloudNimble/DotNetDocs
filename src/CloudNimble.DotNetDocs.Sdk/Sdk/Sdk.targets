<Project>
    <!-- ============================================================================
        DotNetDocs.Sdk - Targets

        Provides build targets for documentation projects (.docsproj)
        Includes validation, generation, and integration targets.
        ============================================================================ -->

    <!-- Debug: Confirm targets file is loaded -->
    <Target Name="DotNetDocsTargetsLoaded" BeforeTargets="Build">
        <Message Text="🔧 DotNetDocs.Sdk targets loaded successfully" Importance="high" />
        <Message Text="   MSBuild: $(MSBuildVersion) ($(MSBuildRuntimeType))" Importance="normal" />
        <Message Text="   Looking for tasks at: $(_DotNetDocsTasksAssembly)" Importance="high" />
        <Message Text="   Task assembly exists: $([System.IO.File]::Exists('$(_DotNetDocsTasksAssembly)'))" Importance="high" />
    </Target>

    <!-- Import the NoTargets SDK targets for no-compile behavior -->
    <!-- NoTargets SDK files are bundled in the Sdk/NoTargets folder -->
    <!-- First try the local NoTargets folder (for packaged SDK) -->
    <Import Project="$(MSBuildThisFileDirectory)NoTargets\Sdk.targets" 
            Condition="Exists('$(MSBuildThisFileDirectory)NoTargets\Sdk.targets')" />
    
    <!-- Fallback: Try common NuGet package locations if local doesn't exist -->
    <PropertyGroup Condition="!Exists('$(MSBuildThisFileDirectory)NoTargets\Sdk.targets')">
        <!-- Try standard NuGet cache location -->
        <_NoTargetsTargetsFallbackPath>$(UserProfile)\.nuget\packages\microsoft.build.notargets\3.7.0\Sdk\Sdk.targets</_NoTargetsTargetsFallbackPath>
        <!-- For CI environments that might use different cache -->
        <_NoTargetsTargetsFallbackPath Condition="!Exists('$(_NoTargetsTargetsFallbackPath)')">$(NuGetPackageRoot)microsoft.build.notargets\3.7.0\Sdk\Sdk.targets</_NoTargetsTargetsFallbackPath>
    </PropertyGroup>
    
    <!-- Import from NuGet cache if found -->
    <Import Project="$(_NoTargetsTargetsFallbackPath)" 
            Condition="!Exists('$(MSBuildThisFileDirectory)NoTargets\Sdk.targets') and Exists('$(_NoTargetsTargetsFallbackPath)')" />
    
    <!-- Determine which task assembly to load based on MSBuild runtime -->
    <PropertyGroup>
        <!-- Determine the target framework for tasks based on MSBuild runtime -->
        <_DotNetDocsTaskFramework Condition="'$(MSBuildRuntimeType)' == 'Core'">net8.0</_DotNetDocsTaskFramework>
        <_DotNetDocsTaskFramework Condition="'$(MSBuildRuntimeType)' == 'Full'">netstandard2.0</_DotNetDocsTaskFramework>
        <_DotNetDocsTaskFramework Condition="'$(_DotNetDocsTaskFramework)' == ''">net8.0</_DotNetDocsTaskFramework>
    </PropertyGroup>
    
    <!-- Determine if we're in local development or packaged SDK -->
    <!-- Check if the Tasks source file exists (which means we're in development) -->
    <PropertyGroup>
        <_IsLocalDevelopment Condition="Exists('$(MSBuildThisFileDirectory)..\Tasks\GenerateDocumentationTask.cs')">true</_IsLocalDevelopment>
        <_IsLocalDevelopment Condition="'$(_IsLocalDevelopment)' == ''">false</_IsLocalDevelopment>
    </PropertyGroup>
    
    <!-- Set task assembly path based on development vs packaged state -->
    <PropertyGroup Condition="'$(_IsLocalDevelopment)' == 'true'">
        <!-- For local development, use the bin folder directly -->
        <_DotNetDocsTasksFolder>$(MSBuildThisFileDirectory)..\bin\$(Configuration)\$(_DotNetDocsTaskFramework)</_DotNetDocsTasksFolder>
        <_DotNetDocsTasksAssembly>$(_DotNetDocsTasksFolder)\CloudNimble.DotNetDocs.Sdk.dll</_DotNetDocsTasksAssembly>
    </PropertyGroup>
    
    <PropertyGroup Condition="'$(_IsLocalDevelopment)' != 'true'">
        <!-- For packaged SDK, use the tasks folder -->
        <_DotNetDocsTasksFolder>$(MSBuildThisFileDirectory)..\tasks\$(_DotNetDocsTaskFramework)</_DotNetDocsTasksFolder>
        <_DotNetDocsTasksAssembly>$(_DotNetDocsTasksFolder)\CloudNimble.DotNetDocs.Sdk.dll</_DotNetDocsTasksAssembly>
    </PropertyGroup>
    
    <!-- Override GenerateDocumentation if task assembly doesn't exist yet -->
    <!-- This handles the first build scenario where the SDK hasn't been built yet -->
    <PropertyGroup>
        <GenerateDocumentation Condition="!Exists('$(_DotNetDocsTasksAssembly)')">false</GenerateDocumentation>
    </PropertyGroup>
    
    <!-- Load compiled MSBuild tasks only when GenerateDocumentation is true -->
    <!-- Since we set GenerateDocumentation to false when the assembly doesn't exist, this is sufficient -->
    <UsingTask TaskName="CloudNimble.DotNetDocs.Sdk.Tasks.DiscoverDocumentedProjectsTask" 
               AssemblyFile="$(_DotNetDocsTasksAssembly)"
               Condition="'$(GenerateDocumentation)' == 'true'" />
    <UsingTask TaskName="CloudNimble.DotNetDocs.Sdk.Tasks.GenerateDocumentationTask" 
               AssemblyFile="$(_DotNetDocsTasksAssembly)"
               Condition="'$(GenerateDocumentation)' == 'true'" />
    
    <!-- Clean up any implicit package references that might cause warnings -->
    <Target Name="RemoveImplicitPackageReferences" BeforeTargets="CollectPackageReferences">
        <ItemGroup>
            <PackageReference Remove="NETStandard.Library" />
            <PackageReference Remove="Microsoft.NETCore.App" />
        </ItemGroup>
    </Target>


    <!-- Debug: Show GenerateDocumentation property value -->
    <Target Name="DebugGenerateDocumentation" BeforeTargets="ValidateDocumentationProject">
        <Message Text="🔧 GenerateDocumentation property: '$(GenerateDocumentation)'" Importance="high" />
    </Target>

    <!-- Documentation project validation and information -->
    <Target Name="ValidateDocumentationProject" BeforeTargets="Build">
        <Message Text="✅ Documentation project: $(MSBuildProjectName)" Importance="high" />
        <Message Text="📄 Documentation type: $(DocumentationType)" Importance="high" />
        <Message Text="📂 Documentation root: $(DocumentationRoot)" Importance="high" Condition="'$(DocumentationRoot)' != '$(MSBuildProjectDirectory)\'" />
        <Message Text="📁 Output redirected to: $(ApiReferencePath)" Importance="normal" Condition="'$(KeepLocalOutput)' != 'true'" />
        <Message Text="📁 Output kept local" Importance="normal" Condition="'$(KeepLocalOutput)' == 'true'" />
        <Message Text="🔧 Generate documentation: $(GenerateDocumentation)" Importance="normal" />
    </Target>

    <!-- Discover documented projects in solution for documentation generation -->
    <Target Name="DiscoverDocumentedProjects" Condition="'$(GenerateDocumentation)' == 'true'" AfterTargets="ValidateDocumentationProject">
        <Message Text="🔍 Discovering documented projects in solution..." Importance="high" />

        <!-- Use compiled task to discover projects -->
        <CloudNimble.DotNetDocs.Sdk.Tasks.DiscoverDocumentedProjectsTask
            SolutionDir="$(MSBuildProjectDirectory)\.."
            ExcludePatterns="*.Tests.*;*.Test">
            <Output TaskParameter="DocumentedProjects" ItemName="DocumentedProjects" />
        </CloudNimble.DotNetDocs.Sdk.Tasks.DiscoverDocumentedProjectsTask>

        <Message Text="   Found @(DocumentedProjects->Count()) documented projects" Importance="normal" />

        <ItemGroup>
            <DocumentedProjects Include="@(AllProjectFiles)" />
        </ItemGroup>

        <Message Text="📚 Found @(DocumentedProjects->Count()) documented projects for documentation" Importance="high" />
        
        <!-- Show the list of projects that will be documented -->
        <ItemGroup>
            <_ProjectNames Include="@(DocumentedProjects->'%(Filename)')" />
        </ItemGroup>
        <Message Text="   Projects: @(_ProjectNames, ', ')" Importance="normal" />
    </Target>

    <!-- Build discovered projects and generate documentation -->
    <Target Name="GenerateDocumentation"
            Condition="'$(GenerateDocumentation)' == 'true'"
            AfterTargets="Build"
            DependsOnTargets="DiscoverDocumentedProjects">
        <Message Text="🚀 Generating unified documentation from solution..." Importance="high" />

        <!-- Build all documented projects to ensure assemblies are up to date -->
        <MSBuild Projects="@(DocumentedProjects)"
                 Targets="Restore;Build"
                 ContinueOnError="false" />

        <Message Text="✅ Successfully built @(DocumentedProjects->Count()) projects" Importance="normal" />

        <!-- Extract assembly paths from built projects (only main project assemblies) -->
        <ItemGroup>
            <!-- Get assembly paths using the actual target framework from each project -->
            <AssemblyPaths Include="%(DocumentedProjects.RootDir)%(DocumentedProjects.Directory)bin\$(Configuration)\%(DocumentedProjects.TargetFramework)\%(DocumentedProjects.Filename).dll" />
            <XmlDocPaths Include="%(DocumentedProjects.RootDir)%(DocumentedProjects.Directory)bin\$(Configuration)\%(DocumentedProjects.TargetFramework)\%(DocumentedProjects.Filename).xml" />
        </ItemGroup>

        <Message Text="📁 Found @(AssemblyPaths->Count()) assemblies for documentation generation" Importance="normal" />
        
        <!-- Debug: Show assembly paths -->
        <Message Text="   Assembly: %(AssemblyPaths.Identity)" Importance="normal" />

        <!-- Call DocumentationManager to process assemblies -->
        <PropertyGroup>
            <DocumentationRootPath>$(MSBuildProjectDirectory)</DocumentationRootPath>
            <NamespaceModeProperty>$(NamespaceMode)</NamespaceModeProperty>
        </PropertyGroup>

        <!-- Create assembly list file for DocumentationManager (for debugging) -->
        <WriteLinesToFile File="$(MSBuildProjectDirectory)\assembly-list.txt"
                         Lines="@(AssemblyPaths)"
                         Overwrite="true"
                         Condition="'$(Configuration)' == 'Debug'" />

        <Message Text="📝 Created assembly list: $(MSBuildProjectDirectory)\assembly-list.txt" Importance="normal" Condition="'$(Configuration)' == 'Debug'" />
        <Message Text="🔧 Calling GenerateDocumentationTask with @(AssemblyPaths->Count()) assemblies" Importance="high" />

        <!-- Use compiled task to generate documentation -->
        <CloudNimble.DotNetDocs.Sdk.Tasks.GenerateDocumentationTask
            Assemblies="@(AssemblyPaths)"
            OutputPath="$(DocumentationRootPath)"
            DocumentationType="$(DocumentationType)"
            NamespaceMode="$(NamespaceMode)"
            ApiReferencePath="$(ApiReferencePath)">
            <Output TaskParameter="GeneratedFiles" ItemName="GeneratedDocumentationFiles" />
        </CloudNimble.DotNetDocs.Sdk.Tasks.GenerateDocumentationTask>

        <!-- Check result -->
        <Message Text="✅ Documentation generation completed successfully" Importance="high" />
        <Message Text="📄 Generated @(GeneratedDocumentationFiles->Count()) documentation files" Importance="normal" Condition="@(GeneratedDocumentationFiles->Count()) > 0" />

        <!-- DocumentationManager integration complete - merged model processing enabled -->
    </Target>

    <!-- Optional: Mintlify integration -->
    <Target Name="GenerateMintlifyDocs"
            Condition="'$(GenerateMintlifyDocs)' == 'true' AND '$(DocumentationType)' == 'Mintlify'"
            AfterTargets="Build">
        <Message Text="🚀 Generating Mintlify documentation..." Importance="high" />

        <!-- TODO: Implement Mintlify documentation generation -->
        <Message Text="⚠️ Mintlify generation not yet implemented" Importance="normal" />
    </Target>


    <!-- Optional: Link validation -->
    <Target Name="ValidateLinks"
            Condition="'$(ValidateLinks)' == 'true'"
            AfterTargets="Build">
        <Message Text="🔗 Validating documentation links..." Importance="high" />
        <!-- This would require a custom tool or script -->
        <Message Text="Link validation not implemented yet - install markdown-link-check or similar tool" Importance="low" />
    </Target>

    <!-- Optional: Documentation preview -->
    <Target Name="PreviewDocumentation"
            Condition="'$(PreviewDocumentation)' == 'true'"
            AfterTargets="Build">
        <Message Text="👀 Starting documentation preview..." Importance="high" />

        <!-- Mintlify preview -->
        <Exec Command="mint dev"
              WorkingDirectory="$(DocumentationRoot)"
              ContinueOnError="true"
              IgnoreExitCode="true"
              Condition="'$(DocumentationType)' == 'Mintlify'" />

        <!-- DocFX preview -->
        <Exec Command="docfx --serve"
              WorkingDirectory="$(DocumentationRoot)"
              ContinueOnError="true"
              IgnoreExitCode="true"
              Condition="'$(DocumentationType)' == 'DocFX'" />

        <!-- MkDocs preview -->
        <Exec Command="mkdocs serve"
              WorkingDirectory="$(DocumentationRoot)"
              ContinueOnError="true"
              IgnoreExitCode="true"
              Condition="'$(DocumentationType)' == 'MkDocs'" />

        <!-- Jekyll preview -->
        <Exec Command="bundle exec jekyll serve"
              WorkingDirectory="$(DocumentationRoot)"
              ContinueOnError="true"
              IgnoreExitCode="true"
              Condition="'$(DocumentationType)' == 'Jekyll'" />

        <!-- Hugo preview -->
        <Exec Command="hugo server"
              WorkingDirectory="$(DocumentationRoot)"
              ContinueOnError="true"
              IgnoreExitCode="true"
              Condition="'$(DocumentationType)' == 'Hugo'" />
    </Target>

    <!-- Optional: Generate PDF documentation -->
    <Target Name="GeneratePdf"
            Condition="'$(GeneratePdf)' == 'true'"
            AfterTargets="Build">
        <Message Text="📄 Generating PDF documentation..." Importance="high" />
        <!-- This would require pandoc or similar tool -->
        <Message Text="PDF generation not implemented yet - install pandoc or similar tool" Importance="low" />
    </Target>

    <!-- Optional: Documentation deployment -->
    <Target Name="DeployDocumentation"
            Condition="'$(DeployDocumentation)' == 'true'"
            AfterTargets="Build">
        <Message Text="🚀 Deploying documentation..." Importance="high" />

        <!-- Mintlify deployment -->
        <Exec Command="mint deploy"
              WorkingDirectory="$(DocumentationRoot)"
              ContinueOnError="true"
              IgnoreExitCode="false"
              Condition="'$(DocumentationType)' == 'Mintlify'" />

        <!-- GitHub Pages deployment (generic) -->
        <Message Text="Configure GitHub Actions or other CI/CD for deployment"
                 Importance="normal"
                 Condition="'$(DocumentationType)' != 'Mintlify'" />
    </Target>

    <!-- Documentation project statistics -->
    <Target Name="DocumentationStats"
            Condition="'$(ShowDocumentationStats)' == 'true'"
            AfterTargets="Build">
        <Message Text="📊 Documentation Statistics:" Importance="high" />

        <ItemGroup>
            <MarkdownFiles Include="$(DocumentationRoot)**/*.md" />
            <MarkdownFiles Include="$(DocumentationRoot)**/*.mdx" />
            <MarkdownFiles Include="$(DocumentationRoot)**/*.mdz" />
            <ImageFiles Include="$(DocumentationRoot)**/*.png;$(DocumentationRoot)**/*.jpg;$(DocumentationRoot)**/*.jpeg;$(DocumentationRoot)**/*.gif;$(DocumentationRoot)**/*.svg" />
        </ItemGroup>

        <Message Text="   📄 Documentation type: $(DocumentationType)" Importance="high" />
        <Message Text="   📝 Markdown files: @(MarkdownFiles->Count())" Importance="high" />
        <Message Text="   🖼️ Image files: @(ImageFiles->Count())" Importance="high" />
    </Target>

    <!-- Override GetTargetPath to provide a marker file for terminal logger -->
    <!-- This overrides the empty GetTargetPath from NoTargets SDK -->
    <Target Name="GetTargetPath" Returns="@(TargetPathItem)">
        <PropertyGroup>
            <!-- Create a marker file path that represents our documentation output -->
            <!-- This needs to be a file path, not a directory, to avoid MSB3024 error -->
            <TargetPath>$(MSBuildProjectDirectory)\bin\$(Configuration)\$(MSBuildProjectName).docmarker</TargetPath>
        </PropertyGroup>
        <ItemGroup>
            <TargetPathItem Include="$(TargetPath)">
                <TargetFramework>$(TargetFramework)</TargetFramework>
            </TargetPathItem>
        </ItemGroup>
    </Target>

    <!-- Override GetTargetPathWithTargetPlatformMoniker as well -->
    <Target Name="GetTargetPathWithTargetPlatformMoniker" Returns="@(TargetPathWithTargetPlatformMoniker)">
        <PropertyGroup>
            <!-- Use the same marker file path as GetTargetPath -->
            <TargetPath>$(MSBuildProjectDirectory)\bin\$(Configuration)\$(MSBuildProjectName).docmarker</TargetPath>
        </PropertyGroup>
        <ItemGroup>
            <TargetPathWithTargetPlatformMoniker Include="$(TargetPath)">
                <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
                <TargetFramework>$(TargetFramework)</TargetFramework>
            </TargetPathWithTargetPlatformMoniker>
        </ItemGroup>
    </Target>
    
    <!-- Override CopyFilesToOutputDirectory to prevent the copy operation entirely -->
    <!-- Since we're a documentation project, we don't need to copy files to output -->
    <Target Name="CopyFilesToOutputDirectory" />



    <!-- Help target to show available options -->
    <Target Name="DocumentationHelp">
        <Message Text="" Importance="high" />
        <Message Text="📚 DotNetDocs.Sdk Help" Importance="high" />
        <Message Text="═══════════════════════════════" Importance="high" />
        <Message Text="" Importance="high" />
        <Message Text="Available Properties:" Importance="high" />
        <Message Text="  KeepLocalOutput=true          - Keep bin/obj in project folder" Importance="high" />
        <Message Text="  GenerateDocumentation=true    - Generate docs from all packable projects in solution" Importance="high" />
        <Message Text="  GenerateMintlifyDocs=true     - Auto-generate Mintlify docs on build" Importance="high" />
        <Message Text="  LintMarkdown=true             - Lint markdown files on build" Importance="high" />
        <Message Text="  ValidateLinks=true            - Validate links on build" Importance="high" />
        <Message Text="  PreviewDocumentation=true     - Start preview server on build" Importance="high" />
        <Message Text="  ShowDocumentationStats=true   - Show documentation statistics" Importance="high" />
        <Message Text="  GeneratePdf=true              - Generate PDF output" Importance="high" />
        <Message Text="  DeployDocumentation=true      - Deploy documentation after build" Importance="high" />
        <Message Text="" Importance="high" />
        <Message Text="Available Targets:" Importance="high" />
        <Message Text="  dotnet build -t:DocumentationHelp       - Show this help" Importance="high" />
        <Message Text="  dotnet build -t:DocumentationStats      - Show documentation statistics" Importance="high" />
        <Message Text="  dotnet build -t:GenerateDocumentation    - Generate unified documentation" Importance="high" />
        <Message Text="  dotnet build -t:GenerateMintlifyDocs     - Generate Mintlify documentation" Importance="high" />
        <Message Text="  dotnet build -t:LintMarkdown             - Lint markdown files" Importance="high" />
        <Message Text="  dotnet build -t:PreviewDocumentation     - Start preview server" Importance="high" />
        <Message Text="" Importance="high" />
        <Message Text="Current Configuration:" Importance="high" />
        <Message Text="  Documentation Type: $(DocumentationType)" Importance="high" />
        <Message Text="  Documentation Root: $(DocumentationRoot)" Importance="high" />
        <Message Text="  Output Location: $(ApiReferencePath)" Importance="high" />
        <Message Text="  Keep Local Output: $(KeepLocalOutput)" Importance="high" />
        <Message Text="  Generate Documentation: $(GenerateDocumentation)" Importance="high" />
        <Message Text="" Importance="high" />
    </Target>

</Project>